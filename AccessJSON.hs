module AccessJSON
( AccessJSON.readFile
, AccessJSON.saveFile
, AccessJSON.readURL
, AccessJSON.Temperature
, AccessJSON.readLocal
, AccessJSON.saveLocal
, AccessJSON.tempsToStr
) where

import Data.Aeson
import Data.ByteString
import GHC.Generics
import Foreign.Marshal.Unsafe
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString.Lazy.Char8 as C
import qualified Data.ByteString as S
import Data.Word8
import Network.HTTP.Conduit (simpleHttp)
import Data.Either
import qualified Data.Sequence as Seq
import Data.List
import System.IO
import Control.DeepSeq

data Temperature = Temperature {
	user :: String,
	date :: String,
	temperature :: Int
} deriving (Show,Generic,Eq)

instance ToJSON Temperature 		
instance FromJSON Temperature 

tempsToStr :: [Temperature] -> String
tempsToStr (x:xs) = show x ++ "\n" ++ tempsToStr xs
tempsToStr [] = []
	
{-- 
	used in read file/URL to remove the Either generated by decodeEither 
	(as decode by itself throws errors).
--}
stripEither :: (Either String [Temperature]) -> [Temperature]
stripEither (Left _) = []
stripEither (Right x) = x	

localJSON = "local.json"

{--
	Uses readFile to read the local JSON storage
--}
readLocal :: [Temperature]
readLocal = AccessJSON.readFile localJSON

{--
	Reads the specified file in the location specified  to retrieve a list 
	of Temperature Aeson Objects.
--}
readFile :: FilePath -> [Temperature]
readFile x = decrypt $ unsafeLocalState $ getFile x

{--
	Takes a Strict ByteString and decodes it into [Temperature], used for 
	both reading and writing to files, so moved to a seperate function.
--}
decrypt :: S.ByteString -> [Temperature]
decrypt x = stripEither decodJSON
	where
		decodJSON = eitherDecode $ cleanJSON :: (Either String [Temperature])
		cleanJSON = B.fromStrict $ S.filter (\y -> not $ isControl y) x
		
{--
	Retrieves the contents of the local.json file as an S.ByteString.
	The second last line was originally 's `deepseq` hClose h', to 
	prevent reading and writing at the same time, however it seems to work
	without this line when it is executed in a do block.
--}
getFile :: FilePath -> IO S.ByteString
getFile x = do 
	h <- openFile x ReadMode
	s <- S.hGetContents h
	hClose h 
	return s

{--
	Used to combine two lists of temperatures for saveFile, it will combine
	bost lists, and then remove all values with the same date value.
	If there is a clash between dates then the values from the first list will
	be prioritised over the values in the second.
	This is used in saveFile to allow newly supplied information to overwrite
	locally stored information.
--}
groupFiles :: [Temperature] -> [Temperature] -> [Temperature]
groupFiles x s =  nubBy (\(Temperature u1 d1 t1) (Temperature u2 d2 t2) -> (u1==u2) && (d1==d2)) $ x ++ s

{--
	Function to save inputs to a file, overwriting any repeating information.
	Currently will break if local.json is not present.
	Could create an error handling system where if openFile does not find the
	file then run the last 3 lines, 'replacing $ groupFiles x $ decrypt s'
	with just 'x', to create a new file with this name. However if the error
	was triggered due to the rare case of two instances of the program
	attempting to access the file simultaneously, the file could be 
	completely overwritten.
--}		
saveFile :: FilePath -> [Temperature] -> IO ()
saveFile f x = do 
	s <- getFile f
	nh <- openFile f WriteMode
	S.hPut nh $ B.toStrict $ encode $ groupFiles x $ decrypt s
	hClose nh

{--
	Uses saveFile to save to the local JSON storage
--}
saveLocal :: [Temperature] -> IO ()
saveLocal x = AccessJSON.saveFile localJSON x	


{--
	stripOB takes a ByteString taken from a URL in the JSON format 
	specified in the README.md file and strips off the outer bracket layer. 
	It does this by dropping everything before the first '[' and taking 
	everything up to the last ']'. Due	to the way the takeWhile function 
	is executed, it will not include the	final ']', so a new one has 
	to be appended.
--}
stripOB :: B.ByteString -> B.ByteString
stripOB x = B.append (drop $ take x) (C.singleton ']')
	where
		drop = B.dropWhile (\x -> not (B.singleton x == C.singleton '['))
		take = B.takeWhile (\x -> not (B.singleton x == C.singleton ']'))
	
{-- 
	If the supplied URL is a json file in the JSON format specified in the 
	README.md file, this function will return a	list of Temperatures. If 
	the supplied URL was not of the correct format, then this function 
	will simply return [], as to avoid errors.
--}
readURL :: String -> [Temperature]
readURL url = stripEither decodJSON 
	where 
		decodJSON = eitherDecode $ cleanJSON :: (Either String [Temperature])
		-- Either Left String or Right [Temperature], dependant on json format
		cleanJSON = stripOB $ noControlJSON 
		-- JSON in the encoded Aeson format.
		noControlJSON = B.filter (\x -> not $ isControl x) rawJSON 
		-- JSON without '\n' etc.
		rawJSON = unsafeLocalState $ getURL url
		-- Initial raw JSON

getURL :: String -> IO B.ByteString
getURL url = simpleHttp url


		
		
